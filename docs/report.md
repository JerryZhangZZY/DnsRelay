# REPORT OF DNS RELAY SERVER

**Course Title:** Design and implementation of a DNS Relay

**Group Member:**

- Wang Zaitian (2019213481)
- Zhang Zeyu (2019213482)

**Date:** 2022/7/2

[TOC]

## 0. Overview

The aim of this project is to design and implement a DNS relay that connects clients with remote DNS servers. Typically, when a user program is trying to interact with the domain name space, it send queries directly to the remote DNS server. In this design, the DNS relay works as a local DNS server or resolver whom the clients resort to, and takes the role of connecting to remote DNS server. The new domain system configuration has two benefits. First, it can ease the burden or remote DNS servers by replying to clients with its own DNS cache. Second, it increase Internet connection speed by using local DNS cache, which is faster than remote DNS server. Third, it can block some undesired connection to the Internet by adding certain domain names to blacklist.

## 1. Requirement Analysis

### 1.1. Functional Requirements

The DNS relay should be able to:

1. Listen to port 53 for DNS queries
2. Receive and resolve DNS query messages
3. Retrieve IPs for the domain name queried in local cache
4. Query the remote DNS server if IP not found in cache
5. Receive remote DNS server reply and fetch the returned IPs
6. Pack the IP from cache or remote DNS server in a reply message
7. Respond the client with this message containing the IP address
8. Block queries for domains that are recorded in blacklist
9. Support multi-threading to given best performance
10. Log connection and  operation information.

### 1.2. Non-functional Requirements

1. The software works on **Windows** or Linux
2. The program is written is C, C++, or **Java**

## 2. Overall Design

### 2.1. Basic Principles

#### 2.1.1. Function of DNS Relay

The DNS relay server is deployed between client and remote DNS server *(Figure 1)*. By adding additional functional modules to this server, we can achieve **additional functions** such as local caching, blacklisting, traffic control, etc.

```mermaid
flowchart BT

A1[Client]
B1[Remote DNS Server]

A2[Client]
B2[DNS Relay]
C2[Remote DNS Server]

A1 <---> B1

A2 <--> B2 <--> C2
```

<center><b><font size ='2'>Figure 1. Traditional & DNS relay</font></b></center></font>

#### 2.1.2. Data Flow

The *Figure 2* below shows the data flow of the whole system.

```mermaid
flowchart TB
A[Client]
B[Resolver]
C[(Cache)]
D[Remote DNS Server]

A --> |request| B
B --> |response| A

subgraph DNS Relay
B --> |save| C
C --> |read| B
end

B --> |request| D
D --> |response| B
```

<center><b><font size ='2'>Figure 2. Functional modules</font></b></center></font>

Client first sends an capsulate UDP datagram request to the resolver. The resolver decapsulates the request and checks if the request domain is cached. If the result is found in cache, it encapsulates the result into a packet and sends it back to the client. Otherwise, it should relay the request to the remote DNS server, and then pass the server's response back to the client. Note that this is just the basic structure of DNS relay which only add a function of local caching.

#### 2.1.3. DNS Datagram

We import a maven dependency [DNSJava](https://mvnrepository.com/artifact/dnsjava/dnsjava) to extract information from DNS datagram conveniently. But we must first have a good understanding about each section of the datagram.

##### 2.1.3.1. DNS Header

The header section of DNS datagram is shown in *Figure 3*. ID is randomly generated by client. And flags indicate some properties of the datagram. The this specific DNS relay application, We only need to care about the **RCODE**. When we get no result for the requested domain or the domain is in the blacklist, we should set RCODE to 3<sub>d</sub>, which means no result. The rest of the header section only needs to be **cloned** to the response datagram without modification.

```
 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|  opcode   |AA|TC|RD|RA|   Z    |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

<center><b><font size ='2'>Figure 3. DNS Header</font></b></center></font>

##### 2.1.3.2. DNS Question

*Figure 4* below shows the structure of DNS question section. **QNAME** contains the requested domain. For example, `www.github.com` is represented as `3www6github3com0`. **QTYPE** indicates different question types. *Table 1* shows the QTYPE that commonly used. QCLASS  = 1 means internet data.

```
 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QNAME                      |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QTYPE                      |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QCLASS                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

<center><b><font size ='2'>Figure 4. DNS Question</font></b></center></font>

| Type  | Code in Decimal | Description            |
| ----- | --------------- | ---------------------- |
| A     | 1               | Request IPv4 address   |
| AAAA  | 28              | Request IPv6 address   |
| CNAME | 5               | Request canonical name |
| PTR   | 12              | Request inverse DNS    |

<center><b><font size ='2'>Table 1. Common QTYPE</font></b></center></font>

##### 2.1.3.3. DNS Answer

We only need to fill the **RDLENGTH** and **RDATA** in the response packet while the rest of the sections only need to be simply cloned. The the DNS relay implementation, only **ARecord**s and **AAAARecord**s need to be attached. This can be achieved by simply call `addRecord()` function defined in DNSJava.

```
  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                     NAME                      |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                     TYPE                      |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                     CLASS                     |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                      TTL                      |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                    RDLENGTH                   |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 |                     RDATA                     |
 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

<center><b><font size ='2'>Figure 5. DNS Question</font></b></center></font>

#### 2.1.4. Possible Datagram

We use **Wireshark** to capture the possible DNS datagram during the whole process. This is very enlightening for us to design and implement the DNS relay.

First use `nslookup` command to request [www.google.com](www.google.com). It returns both an IPv4 address and an IPv6 address(*Figure 6*).

![1](report images/1.png)

<center><b><font size ='2'>Figure 6. nslookup request 1</font></b></center></font>

Then we observe the packets exchange captured in Wireshark in detail(*Figure 7)*. As you can see, a inverse DNS request is firstly sent from port 53 to the remote DNS server(10.0.0.1). After receiving the response, type A and AAAA request and response happens in sequence.

![2](report images/2.png)

<center><b><font size ='2'>Figure 7. Packets captured 1</font></b></center></font>

We also tried the IPv6-only website(*Figure 8*). This is similar to IPv4-only.

![3](report images/3.png)

<center><b><font size ='2'>Figure 8. nslookup request 2</font></b></center></font>

Compare the type A response(*Figure 9*) with the previous one, we found that the **flags** are identical but the latest one has no **Answers** section since [byr.pt](byr.pt) is a IPv6-only website.

![4](report images/4.png)

<center><b><font size ='2'>Figure 9. Packets captured 2</font></b></center></font>

Finally, We tested the case that the domain doesn't exist(*Figure 10*).

![5](report images/5.png)

<center><b><font size ='2'>Figure 10. nslookup request 3</font></b></center></font>

And we found that both type A and type AAAA response have no **Answers** section and the RCODE are set to 3<sub>d</sub>(Figure 11), indicating that no such domain has been found.

![6](report images/6.png)

<center><b><font size ='2'>Figure 11. Packets captured 3</font></b></center></font>

### 2.2. Advanced Server Function Design

#### 2.2.1. IPv6 Support

- Identify the question type and add corresponding records to the answer section.
- Store ipv4 and ipv6 addresses separately in cache.

#### 2.2.2. Flow Control

- **Averaging** the flow by distributing IP addresses equally to each request.
- Only necessary when a large number of requests are received in a short period of time.
- Implement flow control by simply return one address **randomly** can get a nice effect.

#### 2.2.3. Customizable Server Configuration

- Create **boot.properties** as the config file of the DNS relay server.
- Stores server settings in it and can be edited by users.
- Read configurations at the beginning of the program an set as instance vars.
- Use **default** settings if config load failed.

#### 2.2.4. Configurable Cache Auto-cleaning

- Add an attribute of cache limit in boot.properties.
- Initialize a scheduled executor **service** at the beginning of the main thread.
- The service will run once first and wake up every **24 hours**.
- The service **clears** the expired cache and **updates** cache map in RAM.

#### 2.2.5. Blacklist with Expiry Time

- If the returned address is [0.0.0.0](0.0.0.0) (for IPv4) or [::](::) (for IPv6), then the requested domain is in **blacklist**. The program will set the **RCODE** to 3<sub>d</sub> and send the response.
- Set the **timestamp** to a chosen date and the cache **cleaning** service will delete 

#### 2.2.6. Configurable remote DNS server

- Add an attribute of the remote DNS server IP in boot.properties.
- Get it from instance var and **encapsulate** into datagram when need to send request to the remote server.

#### 2.2.7. Configurable Cache Usage

- Add an attribute of cache usage IP in boot.properties.
- **Skip** finding result in cache and request to remote server directly of it is set to FALSE.

#### 2.2.8. Configurable Multithreading

- Add an attribute of thread pool size in boot.properties.
- Initialize a **thread pool** of the given size.
- When the main thread **receives** a request, **pick** a new thread from the thread pool and start the **resolver** task in the new thread.

#### 2.2.9. Logging

- Implement a log class which can generate logs and save **locally**.
- The log records the behaviour of the server in detail.
- **Print** to the terminal simultaneously.

### 2.3. Module Decomposition

The following treemap shows the module decomposition of the whole system.

```mermaid
graph TB

A[DNS Relay]
B(Request Receiving Module)
B1(Resolver Module)
B2(Log Module)
B3(Cache Module)
C(Request Handling Module)
D(Cache Cleaning Mudule)
E(Configuration Module)

A --- B
A --- C
A --- D
A --- E
C --- B1
C --- B2
C --- B3
```

<center><b><font size ='2'>Figure 12. Module tree</font></b></center></font>

### 2.4. Overall Flow

Below you can see the major **work flow** of our relay system(cache cleaning module excluded). For detailed description see [Module Design](#3. Module Design) right below.

```mermaid
flowchart TB

st([Start])
1[/Read config/]
2[Block at receive]
3[Request received]
4[Pick a new thread from thread pool]
5[Resolve request]
6{Domain in cache?}
7[Get ip from cache]
8[Relay request to remote DNS server]
9[Get ip from remote]
10[[Add to cache]]
11{Valid ip?}
12[Encapsulate ip into datagram]
13[Set RCODE = 3<sub>d</sub>]
14[Send response back to client]
nd([End of child thread])

st-->1-->2-->3-->4-->2
4-->5-->6
6-->|true|7-->11
6-->|false|8-->9-->11
9-->|Child thread|10
11-->|true|12-->14
11-->|false|13-->14
14-->nd
```

<center><b><font size ='2'>Figure 13. Overall flowchart</font></b></center></font>

## 3. Module Design

### 3.1 Request Receiving Module

First prepare a packet with buffer to store the request received later.

```java
byte[] buf = new byte[1024];
DatagramPacket request = new DatagramPacket(buf, buf.length);
```

DNS Protocol uses port 53 to transfer data, so we need to create a socket and bind it to port 53 to receive the packet.

```java
DatagramSocket socket;
try {
    socket = new DatagramSocket(53);
} catch (SocketException e) {
    throw new RuntimeException(e);
}
```

When a request is send to the socket, we can get it by:

```java
try {
    socket.receive(request);
} catch (IOException e) {
    e.printStackTrace();
}
```

And if there is no traffic, the thread will be blocked at `DatagramSocket.receive()`. 

The `receive()` method runs infinitely in a while loop without handling the request to boost performance. And requests are handled by child threads from a pool with our request handler.

```java
pool.execute(new Handler(request, socket, cache, new Log(), remoteDnsServer, useCache));
```

The workflow of this part can be understood as below.

```mermaid
flowchart TB

st([Program Starts])
1[Prepare a Empty Request]
2[Create a Socket]
3[Bind the Socket to Port 53]
4[Block at Receive]
5[Receive Request]
6[Pick a New Thread from Thread Pool]
7([to Request Handling Module])

st-->1-->2-->3-->4-->5-->6-->4
6-->7

11[/Client Socket/]
12[/Send/]

11-->12
12-..->5

```

### 3.2 Request Handling Module



#### 3.2.1 Resolver Module

#### 3.2.2 Log Module

#### 3.2.3 Cache Module

### 3.3 Cache Cleaning Mudule

### 3.4 Configuration Module

## 4. Testing & Results

## 5. Summary & Future Improvement

### 5.1. Summary

The DNS relay program is capable of handling various DNS query requests. On entering `nslookup example.com localhost` in `cmd`, the relay program receives the question from resolver and return with a answer from its local cache or remote DNS server. Apart from IPv4, the program has support for **IPv6** DNS query by returning type AAAA record, and it can also deal with records of other types including **NS, CNAME, and MX**. By using **a thread pool**, the server is able to handle multiple request at the same time. This **concurrency** configuration greatly helps improve the performance of the program. Mutex Lock is used to ensure **thread-safe** and avoid race condition.  In order to easy to burden or remote DNS server and speed up DNS look-up, the program uses a **cache** to store DNS query result for a preconfigured period of time and expired DNS cache is **automatically flushed**. The cache is supported by a **hash map** in the memory, which means any query in the cache can be done with time complexity of $O(1)$, and thus other threads is very unlikely to be blocked when they access the cache. This program also enables **flow control**. If multiple IP addresses are found in cache or received from remote server (which means the Internet service has many servers for load balancing), it will randomly select one to send back to resolver. In this way, user programs access the service via different IP addresses and servers fairly. **Log** functions is used to record the connection and operations of the relay program. Users can track all query and response records in the log file.

### 5.2. Room for Improvements

- Blacklist can be separate from cache so that it can be maintained more conveniently
- Log can be clearable in case the file is very large
- Cache size limit can be used to restrain memory usage
- Request receiving can use a queue to deal with enormous traffic (, which is unlikely to happen on localhost but would be useful is deployed as a public remote DNS server).
